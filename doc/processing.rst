.. _Processing geospatial data with GeoScript:

Processing geospatial data with GeoScript
=========================================


We have already seen how to directly edit and modify both vector and raster data. There are many things that can be done with the methods from the :class:`RasterLayer` and :class:`VectorLayer` classes, ranging from simple calculation to more complex analytical tasks. Although it is easy to create those task due to the simple  nature of GeoScript, it might not be a good idea to do so, specially in terms of performance. Simplicity comes at a cost, and, like most high level languages, GeoScript sacrifices performances to have a simpler syntax and reduce the number of lines of code you have to wirte to accomplish a given task.

That means that it is generally not a good idea (unles you are working with small datasets) to write your geoprocessing ideas in Geoscript, but it does not necessarily means that GeoScript is not meant for geoprocessing. In fact, geoprocessing is one of the strongest parts of GeoScript, but it has a different approach. Instead of being a language designed to create your own algorithmic ideas from scratch, it is meant as the 'glue' to connect preexisting algorithms into a custom workflow. Based on an comprehensive and atomized collection of geoprocesses, GeoScript should be used to create more complex calculations that link several of this basic processes into a well-defined workflow.

To understand how this works before we start typing code and having a look at some examples, here are some basic ideas that might help you get an idea about how the processing part of GeoScript has been conceived.

- GeoScript wraps GeoTools. That means that you cannot only use element from GeoTools such as geometries and projections (as it was explained here), but also all the geoprocesses that can be found as part of GeoTools, and which rely on the powerful GeoTools' Processing API

- Just like GeoScript makes it easier to access other elements in GeoTools, it also simplifies its Processing API, so calling geoprocesses gets as easy as it can get.

- GeoScript contains its own processing API, that not just leverages acess to GeoTools algorithms, but also to other ones coming from different applications and libraries. This is completely transparent for the user, who doesn't have to worry about where his data is being processed or even the format that data is in, since GeoScript handles all that transparently.

- In short, GeoScript links your data with the processes that you need in the most practical way, so you can concentrate on creating meaningful analyses and taking the most out of the results you get.

A common processing task in GeoScript involves the following steps:

- Finding a suitable process to run
- Preparing data to be passed to the process
- Running the process
- Using the result generated by the process

Let's have a look at those tasks separately.


Finding a process
------------------

The number of processes available from GeoScript is rather large, specially when external applications are configured and used. You can get a simple list with all the available processes, by calling the :meth:`processes` method in the :mod:`processing` module.

::.

    >>> import from geoscript.processing import processes, processhelp
    >>> processes()
	gs:Aggregate--------------------------->Computes one or more aggregation functions 
	                                        on a feature attribute. Functions include 
	                                        Count, Average, Max, Median, Min, StdDev, 
	                                        and Sum. 
	gs:Bounds------------------------------>Computes the bounding box of the input features. 
	                                        
	gs:BufferFeatureCollection------------->Buffers features by a distance value supplied 
	                                        either as a parameter or by a feature attribute. 
	                                        Calculates buffers based on Cartesian distances. 
	                                        
	gs:Centroid---------------------------->Computes the geometric centroids of features 
	                                        
	gs:Clip-------------------------------->Clips (crops) features to a given geometry 
	                                        
	gs:CollectGeometries------------------->Collects the deafult geometries of the input 
	                                        features and combines them into a single 
	                                        geometry collection 
	gs:Count------------------------------->Computes the number of features in a feature 
	                                        collection. 
	gs:Feature----------------------------->Converts a geometry into a feature collection. 
	                                        
	gs:Grid-------------------------------->Generates a georeferenced regular grid of 
	                                        cells.  Output contains the attributes: cell 
	                                        - the cell polygon; id - a unique identifier; 
	                                        centerX and centerY - the ordinates of the 
	                                        cell center. 
	.
	.
	.
 
Notice that we have imported from the :mod:`processing` module. All the methods that we are going to use are part of that module, as it is the entry point for geoprocessing in GeoScript.
 
The left part of each line contains the name of the algorithm, while the right one contains a description of what it does. The left part is used to later called algorithms and identify them, so it is what we will be using for further examples.
 
 
The list is probably larger than what fits in a single screen (we have not included the full list in the above example), and that does not seem to be a very practical way of finding an algorithm. You can, however, easily restrict it to just a small group of processes by passing a string to the :meth:`processes` method. In this case, it will just show you those algorithms that contain that string in their name or description. For instance, let's suppose that you want to calculate a slope layer from a DEM. The process to perform that calculation is likely to have the string 'slope' in its name, you we can use it.
 
::.

	>>> processes('slope')
	XXXXXXX
 
Now we have a smaller list of processes and we can select the one that we want to run, in this cased called "*****". 

Using the :meth:`lookup` method you can get an instance of a given process.

::.

	>>> proc = lookup('XXXXXslope')

  
Having the instance of the process, you can also run it query it about its requirements, calling the corresponding methods that we will see soon.


Preparing data for a process
-----------------------------
 
Processes need data to run. The slope process that we want to run also needs data, and we have to know which kind of data we need. The :meth:`processhelp` method prints information about all the inputs that an algorithm needs, and also about the output it produces, so you know which data you have to use and which data you should expect from the algorithm. To describe a particular process, just pass its name to the :meth:`processhelp` method.

::.

	>>> processhelp('******slope')
	XXXXXXX
 
If you have an instance of the process, just call its :meth:`help` method to get the same result.

::.

	>>> proc.help()
	XXXXXXX
 

The information printed by GeoScript tells us the kind of data the algorithm needs, and does so by showing the name of each parameter and output, along with the class each of this elements belongs to. Classes are derived from the base classes :class:`Parameter` and :class:`Output`.

When a certain parameter is presented along with the name of class extending :class:`Parameter`, that doesn't mean that you have to create an object of that class and use it when running algorithm. Classes extending :class:`Parameter` are just containers for the actual parameter values, and they do not have to be instantiated. You should understand them as a way of telling you which data the algorithm is expecting, but the value to be passed is not an instance of :class:`Parameter`.

Let's see an example with the *Elevation* parameter in the *XXXXSlope* process above. The information printed by :meth:`getprocesshelp` tells us that this parameter is of class :class:`ParameterRaster`. Basically, that tells you that when you want to run the process you have to pass it *something that represents a raster layer*. What kind of object can you use for that? Depending on the type of parameter, different objects can be used, but usually there are several options for each one. In the case of a raster layer, the most obvious one is a :class:`Raster` object, so you could call the :meth:`run` method of our algorithm with something like this (don't worry if this doesn't make sense to you, specially considering the nuber of parameters needed. We will see more about the *run* method in a while):

::.

	>>> raster = GeoTIFF('dem.tif')
	>>> result = proc.run(dem=raster)
	XXXXXXX

Another possible option is to pass directly a string with the path to a suitable file. So there is no need to create the :class:`GeoTIFF` object, since we can use the path string and GeoScript will internally take care of loading it if necessary.

By handling parameters this way, GeoScript allows you to call all of its available processes in a similar manner, without worring about their origin. As it was said, GeoScript also includes processes from 3rd party application, which most likely will have different requirements in terms of data formats. However, you can use the same object for all processes that need a given type of parameter, and GeoScript will take care of adapting or converting them if needed, depending of what the process doing the actual computation accepts.

In particular, the slope process that we have just run comes from an application called SAGA, which does not support GeoTools object at all, and which doesn't even support TIF files, but just raster files in its own format. However, you can use both a string with the path to a TIF file or a :class:`Raster` object when running that slope process, since GeoScript will do all the hard work for you.

Below you have a list of all possible types of parameters and the type of values that you can use for each of them.

- *ParameterRaster*: 
	- A string representing the filepath to a raster layer.
	- A :class:`Raster` object.	
- *ParameterVector*: 
	- A string representing the filepath to a vector layer.
	- A :class:`Layer` object.
- *ParameterTable*:
	- A string representing the filepath to a table object layer, for instance a DBF file.
	- A bidimensional list.
- *ParameterString*:
	- A string object
- *ParameterNumber*: This parameter represents a numerical value. It might have lower and/or upper bounds, shown along with the description of the parameter type
	- A number object
	- A string containing a numerical value
- *ParameterCrs*:
	- A number object representing a valid EPSG code
	- A string containing a numerical value representing a valid EPSG code
	- A :class:`Projection` object
- *ParameterMultipleInput*: This parameter represents a set of input layer (raster or vector) or tables. A list shoud be passed containing any combination of valid objects for the type of input. For instance, for a multiple input of type raster you should pass a list of object, all of which should be valid objects to be used in the case of a parameter of type *ParameterRaster*.
- *ParameterExtent*:
	- A :class:`Bounds` object
	- A list with 4 numerical values, representing xmin, xmax, ymin, ymax values to define a extent
	- A string with 4 comma-separated values representing, in this order, xmin, xmax, ymin, ymax values to define a extent
- *ParameterSelection*: This parameter represents an object to be selected from a set of available options. An integer value representing the zero-based order of the chosen option must be passed.
- *ParameterBoolean*:
	- A boolean value
	- A string with the string "true" (not case-sensitive) to represent the true vale, or any other string to represent the false value.
- *ParameterFixedTable*: This parameter represents a small table such as those used for a lookup table or a kernel filter. It should be passed as a bidimensional list

- *ParameterTableField*: This parameter reprsents a field in a table (whether an independent one, or from a vector layer). The description will show also the parent parameter it depends on .

You might find some processes with inputs of type :class:`ParameterObject` and, along with that, a given class name. This is used when the object needed by the algorithm does not exactly match any of the other types, and it acts as a generic container for a parameter value. In this case, you should prepare the corresponding object to use, since GeoScript will not do any checking or conversion. The class names shown in the description 
of the parameter indicates the class type that the algorithm expects to receive.

Once you understand how to handle input values, the next step is to actually pass these values to the :meth:`run` method and run the process, so we can get the results it produces and use them for whatever we want to do, like passing them as input for another process. You might have noticed that the description of the algorithm contained not just `ParameterXXX` types, but also `OutputXXX` ones. We will also see in detail how to work with them.

Executing a process and handling outputs
-----------------------------------------

As you might have already figured out from the last example, the :meth:``run`` method is the one to call to actually run the process and get the work done. The number of parameters of the :meth:`run` method depends on the process to be executed, and these parameters have the names indicated in the process description, including both input parameters and output. So in the case of our slope process, the corresponding run method should have XXXX parameters: *elevation, XXXX*. A complete call to the run algorithm might look like the one below:

.::

	>>>result = proc.run(XXX)

Let's see what is happening here at how it compares to the previous call that we saw in the example above.

The first thing you might notice is that, while this call contains all the parameters declared by the process definition that was printed by the :meth:`help` method, the previous one did not. It just used the *dem* parameter to pass our Tiff file, whatever the format used for that was. This is because some types of parameters have default values, and you can omit them, just like you do on a normal Python method. Basically, all parameter types except :class:`ParameterRaster, ParameterTable, ParameterVector` and :class:`ParameterMultipleInput` can be ommited. These 4 parameter types can be ommited when the parameter is optional, but not when it is mandatory. If the parameter is optional (for instance, a process taking 2 raster layers, one of them not mandatory), the :meth:`help` method will tell you about it when printing the description of parameters.

The second thing that you might notice is that the parameters of the :meth:`run` method corresponding to outputs have also been ommited. We haven't talked about outputs yet, and this is a good time to do it. The only thing you have to know is that the value to pass to a parameter representing an output is a string with a file path that will be used to store that output. If you omit it, GeoScript will decide where to put it, which might be a temporary file, or even not using a file at all, depending on the process. Most of the times, you will omit output values, specially when the process to execute is an intermediate one within a larger processing workflow.

The object returned by the run method is a dictionary object with the names of the outputs (the same ones displayed by the :meth:`help` method) as keys and objects of class :class:`Output` as values. As it happens with object from class :class:`Parameter`, object of class :class:`Output` are just containers for the real output values. To get those output values you should use the corresponding methods in the output object. In the case of a raster layer, a :class:`RasterLayer` object can be obtained using the :meth:`aslayer` method. 

.::

	>>>slope = result['slope']
	>>>slopelayer = slope.asrasterlayer()
	>>>type(slopelayer)
	'RasterLayer'

Just like input parameters can be entered in several different formats, output results can be obtained from the :class:`Output` object in different ones as well. To get a filename refering to the output raster layer, use the :meth:`asfile` method.

Notice that you can always get both the filename and the :class:`RasterLayer` object, no matter how the result was calculated. If (as it happens in this case, since we are calling an external application) the result was generated and saved to a file, calling the :meth:`asrasterlayer` method will cause the :class:`RasterLayer` object to be created from that file. If the process did not use a filename to save results, calling the :meth:`asfile` method will cause it to be saved and a file to be created, and the filepath to that file to be returned.

Once again, GeoScript hides most of the complexity out of data handling.

Below you can see a complete and slightly more complex example. Starting with a Digital Elevation Model stored in a TIFF file, a slope layer computed, and then its average value is calculated directly in GeoScript, without calling an additional process.

.::

	>>>gtiff = GeoTIFF('dem.tif')


Using several layers for a single process
-----------------------------------------

Some processes require more than one layer to be executed. That might mean using several layers of the same kind (raster or vector), or both raster and vector together. Combining several layers requires some extra care to make sure that results are sound, and this section discusses some important ideas that should be taken into account when using more than one layer in a single process.



One of the main concerns when most users have when combining several layers is how to combine raster layers with different extents and cellsizes. Most raster processes assume that input layers have the same extent and cellsize, so the grid of cells that they define exactly matches that of other layers being used. That is, pixel(0,0) in layer A matches pixel (0,0) in layer B, and the same for the rest of pixels and layers.

Among the processes available from GeoScript you can found processes to crop and resample a raster layer (and the :class:`RasterLayer` object has a :meth:`crop` method), which you can use to prepare layers before passing them to the process, making sure that they all have the same dimensions.

Here's a small example of running a process that takes two raster layers, which includes some previous resampling to make one layer match the characteristics of the other before passing both of them to the :meth:`run` method of the process.

.::

	>>> layerA = GeoTIFF ('layerA.tif')
	>>> layerB = GeoTIFF ('layerB.tif')
	>>> layerB = layerB.resample(bbox = layerA.getextent(), size = layerA.getpixelsize())


And here is that same example but using a process to perform the interpolation instead of the built-in :meth:`resample` method

Another important concern is related to CRSs. Both when using raster and vector layer, processes assume that there is no need to reproject layers, and most of them do not even check for consistency in input layers' CRSs. If the process being run makes no actual measurements (which might need to differentiate between projected and geographical coordinates), most of the time the CRS of the layer is completely ignored.

For this reason, you have to perform reprojections manually if needed. The following example shows how a polygon layer is reprojected to the same projection as a raster layer, so statistics of that raster layer within the polygons can be calculated. If the reprojection was not performed, the Process would run, but the results would be wrong. The process would assume that both layers have the same CRS and, under that assumption, the poygon will not fall in the area covered by the raster layer.

.::

	>>>

As it happens with resampling, there are several alternatives for performing a reprojection. Below you can see the above example, using an external process for reprojecting instead of the built-in method.

.::

	>>>


 
 
